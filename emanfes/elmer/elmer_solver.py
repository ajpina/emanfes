#!/usr/bin/python
# -*- coding: iso-8859-15 -*-

# ==========================================================================
# Copyright (C) 2016 Dr. Alejandro Pina Ortega
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ==========================================================================

"""
    Creates Elmer solver.
"""

# ==========================================================================
# Program:   emanfes-solver.py
# Author:    ajpina
# Date:      12/23/17
# Version:   0.1.1
#
# Revision History:
#      Date     Version  Author    Description
#  - 12/23/17:  0.1.1              Call Elmer Solver
#
# ==========================================================================

import subprocess
import numpy as np

from emanfes.geogmsh import GeometryGmsh
from emanfes.misc.constants import *

class ElmerSolver:
    def __init__(self, simulation, rotating_machine):
        self.gmsh_model = GeometryGmsh(simulation, rotating_machine)
        self.pp = rotating_machine.rotor.pp
        self.wm = simulation.load_speed
        self.h_pm = rotating_machine.rotor.magnets[0].material.Br / rotating_machine.rotor.magnets[0].material.mur
        self.mur_pm = rotating_machine.rotor.magnets[0].material.mur
        if rotating_machine.get_machine_type() == "SPM":
            self.r_ag1 = rotating_machine.rotor.outer_radius + rotating_machine.rotor.magnets[0].length
        else:
            self.r_ag1 = rotating_machine.rotor.outer_radius
        self.r_ag2 = rotating_machine.stator.inner_radius
        self.r_middle_ag = (self.r_ag1 + self.r_ag2) / 2.0
        self.stack_length = (rotating_machine.rotor.stack_length + rotating_machine.stator.stack_length) / 2.0
        self.stator_axis = rotating_machine.stator.winding.get_armature_a_axis()
        self.conductor_area = rotating_machine.stator.winding.get_coilside_conductor_area()
        Fe = (self.wm * self.pp) / 60.0
        T = 1.0 / Fe
        self.time_step = T / 180.0
        self.steps = 3
        self.fractions = self.gmsh_model.get_fractions_drawn()
        self.magnets_drawn = int(2 * self.pp / self.fractions)
        if self.magnets_drawn % 2 == 0:
            self.is_even = True
        else:
            self.is_even = False
        self.stator_steel_name = rotating_machine.stator.material.name
        self.stator_steel_BH = np.array(rotating_machine.stator.material.BH)
        self.rotor_steel_name = rotating_machine.rotor.material.name
        self.rotor_steel_BH = np.array(rotating_machine.rotor.material.BH)



    def create(self):
        return self.gmsh_model.create()

    def mesh(self):
        cmd_stator = ['ElmerGrid', '14', '2', 'stator.msh', '-2d', '-autoclean', '-names']
        cmd_rotor = ['ElmerGrid', '14', '2', 'rotor.msh', '-2d', '-autoclean', '-names']
        cmd_unite = ['ElmerGrid', '2', '2', 'stator', '-in', 'rotor', '-unite', '-autoclean', '-names', '-out', 'machine']
        process_stator = subprocess.Popen(cmd_stator, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        (stdout, stderr) = process_stator.communicate()
        process_stator.wait()
        if process_stator.returncode != 0:
            print(stdout)
            print(stderr)

        process_rotor = subprocess.Popen(cmd_rotor, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        (stdout, stderr) = process_rotor.communicate()
        process_rotor.wait()
        if process_rotor.returncode != 0:
            print(stdout)
            print(stderr)

        process_unite = subprocess.Popen(cmd_unite, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        (stdout, stderr) = process_unite.communicate()
        process_unite.wait()
        if process_unite.returncode != 0:
            print(stdout)
            print(stderr)

        boundaries = {}
        bodies = {}
        with open('machine/mesh.names', 'rt') as f:
            for line in f:
                fields = line.strip().split()
                if fields[0] == '$':
                    field_name = fields[1]
                    field_value = fields[3]
                    if field_name.count("BOUNDARY"):
                        boundaries[field_name] = field_value
                    else:
                        bodies[field_name] = field_value

        with open('rotor_material.emf', 'wt') as ro:
            ro.write("! File Generated by emanfes v{0}\n".format( EMANFES_VERSION__ ) )
            ro.write("! Material Name: {0}\n"
                        "! B-H Curve Rotor Material\n"
                        "Electric Conductivity = 0\n"
                        "H-B Curve = Variable coupled iter\n"
                        " Real\t\tCubic Monotone\n".format( self.rotor_steel_name ))
            for i in range(0,self.rotor_steel_BH.shape[1]):
                ro.write("   {0}\t\t{1}\n".format( self.rotor_steel_BH[0,i], self.rotor_steel_BH[1,i] ))
            ro.write("End\n")

        with open('stator_material.emf', 'wt') as ro:
            ro.write("! File Generated by emanfes v{0}\n".format( EMANFES_VERSION__ ) )
            ro.write("! Material Name: {0}\n"
                        "! B-H Curve Stator Material\n"
                        "Electric Conductivity = 0\n"
                        "H-B Curve = Variable coupled iter\n"
                        " Real\t\tCubic Monotone\n".format( self.stator_steel_name ))
            for i in range(0,self.stator_steel_BH.shape[1]):
                ro.write("   {0}\t\t{1}\n".format( self.stator_steel_BH[0,i], self.stator_steel_BH[1,i] ))
            ro.write("End\n")

        with open('emanfes_elmer.sif', 'wt') as fo:
            fo.write("! File Generated by emanfes v{0}\n".format( EMANFES_VERSION__ ) )
            fo.write("$ WM = 2*pi*{0}/60        ! Mechanical Frequency [rad/s]\n".format( self.wm ) )
            fo.write("$ PP = {0}                ! Pole pairs\n".format( self.pp ) )
            fo.write("$ WE = PP*WM              ! Electrical Frequency [Hz]\n" )
            fo.write("$ H_PM = {0}/(pi*4d-7)    ! Magnetisation Magnets [A/m]\n".format( self.h_pm ) )
            fo.write("$ Shift = 2*pi/3          ! Three-phase machine [rad]\n")
            fo.write("$ Gamma = 0               ! Current Angle [rad]\n")
            fo.write("$ Ncond = 20              ! Conductors per coil\n")
            fo.write("$ Cp = 3                  ! Parallel paths\n")
            fo.write("$ Is = 100                ! Stator current [A]\n")
            fo.write("$ Aaxis = {0}             ! Axis Coil A [deg]\n".format(self.stator_axis))
            fo.write("$ Carea = {0}             ! Coil Side Conductor Area [m2]\n".format(self.conductor_area))
            fo.write("\nHeader\n"
                        "\tCHECK KEYWORDS Warn\n"
                        "\tMesh DB \"machine\"\n"
                        "\tInclude Path \".\"\n"
                        "\tResults Directory \".\"\n"
                    "End\n")

            fo.write("\nConstants\n"
                        "\tPermittivity of Vacuum = 8.8542e-12\n"
                    "End\n")

            fo.write("\nSimulation\n"
                        "\tMax Output Level = 4\n"
                        "\tCoordinate System = Cartesian 2D\n"
                        "\tCoordinate Scaling = 1\n"
                        "\tSimulation Type = Transient\n"
                        "\tTimestepping Method = BDF\n"
                        "\tBDF Order = 2\n"
                        "\tTimestep Sizes = $ {0}  ! sampling time\n"
                        "\tTimestep Intervals = {1}              ! steps\n"
                        "\tOutput Intervals = 1\n"
                        "\tUse Mesh Names = Logical True\n"
                    "End\n".format( self.time_step, self.steps ))

            fo.write("\n!--- MATERIALS ---\n")

            fo.write("Material 1\n"
                        "\tName = \"Air\"\n"
                        "\tRelative Permeability = 1\n"
                        "\tElectric Conductivity = 0\n"
                    "End\n")

            fo.write("\nMaterial 2\n"
                     "\tName = \"Wedge\"\n"
                     "\tRelative Permeability = 1\n"
                     "\tElectric Conductivity = 0\n"
                     "End\n")

            fo.write("\nMaterial 3\n"
                        "\tName = \"StatorMaterial\"\n"
                        "\tInclude stator_material.emf\n"
                    "End\n")

            fo.write("\nMaterial 4\n"
                     "\tName = \"RotorMaterial\"\n"
                     "\tInclude rotor_material.emf\n"
                     "End\n")

            fo.write("\nMaterial 5\n"
                     "\tName = \"Copper\"\n"
                     "\tRelative Permeability = 1\n"
                     "\tElectric Conductivity = 48e6\n"
                     "End\n")

            for m in range(1, self.magnets_drawn + 1):
                mat_number = 5 + m
                fo.write("\nMaterial {0}\n"
                            "\tName = \"PM_{1}\"\n"
                            "\tRelative Permeability = {2}\n"
                            "\tMagnetization 1 = Variable time, timestep size\n"
                                "\t\tReal MATC  \"H_PM*cos(WM*(tx(0)-tx(1)) + {3}*pi/PP + {3}*pi + Aaxis*pi/180)\"\n"
                            "\tMagnetization 2 = Variable time, timestep size\n"
                                "\t\tReal MATC \"H_PM*sin(WM*(tx(0)-tx(1)) + {3}*pi/PP + {3}*pi + Aaxis*pi/180)\"\n"
                        "End\n".format( mat_number, m, self.mur_pm, m-1 ) )

            fo.write("\n!--- BODY FORCES ---\n")

            fo.write("Body Force 1\n"
                        "\tName = \"BodyForce_Rotation\"\n"
                        "\t$omega = (180/pi)*WM\n"
                        "\tMesh Rotate 3 = Variable time, timestep size\n"
                            "\t\tReal MATC \"omega*(tx(0)-tx(1)) + Aaxis\"\n"
                        "End\n")

            fo.write("Body Force 2\n"
                     "\tName = \"J_A_PLUS\"\n"
                     "\tCurrent Density = Variable time, timestep size\n"
                     "\t\tReal MATC \"(Is/Carea) * (Ncond/Cp) * sin(WE * (tx(0)-tx(1)) + Gamma)\"\n"
                     "End\n")

            fo.write("Body Force 3\n"
                     "\tName = \"J_A_MINUS\"\n"
                     "\tCurrent Density = Variable time, timestep size\n"
                     "\t\tReal MATC \"-(Is/Carea) * (Ncond/Cp) * sin(WE * (tx(0)-tx(1)) + Gamma)\"\n"
                     "End\n")

            fo.write("Body Force 4\n"
                     "\tName = \"J_B_PLUS\"\n"
                     "\tCurrent Density = Variable time, timestep size\n"
                     "\t\tReal MATC \"(Is/Carea) * (Ncond/Cp) * sin(WE * (tx(0)-tx(1)) - Shift + Gamma)\"\n"
                     "End\n")

            fo.write("Body Force 5\n"
                     "\tName = \"J_B_MINUS\"\n"
                     "\tCurrent Density = Variable time, timestep size\n"
                     "\t\tReal MATC \"-(Is/Carea) * (Ncond/Cp) * sin(WE * (tx(0)-tx(1)) - Shift + Gamma)\"\n"
                     "End\n")

            fo.write("Body Force 6\n"
                     "\tName = \"J_C_PLUS\"\n"
                     "\tCurrent Density = Variable time, timestep size\n"
                     "\t\tReal MATC \"(Is/Carea) * (Ncond/Cp) * sin(WE * (tx(0)-tx(1)) - 2*Shift + Gamma)\"\n"
                     "End\n")

            fo.write("Body Force 7\n"
                     "\tName = \"J_C_MINUS\"\n"
                     "\tCurrent Density = Variable time, timestep size\n"
                     "\t\tReal MATC \"-(Is/Carea) * (Ncond/Cp) * sin(WE * (tx(0)-tx(1)) - 2*Shift + Gamma)\"\n"
                     "End\n")

            fo.write("Body Force 8\n"
                     "\tName = \"J_D_PLUS\"\n"
                     "\tCurrent Density = Variable time, timestep size\n"
                     "\t\tReal MATC \"(Is/Carea) * (Ncond/Cp) * sin(WE * (tx(0)-tx(1)) - 3*Shift + Gamma)\"\n"
                     "End\n")

            fo.write("Body Force 9\n"
                     "\tName = \"J_D_MINUS\"\n"
                     "\tCurrent Density = Variable time, timestep size\n"
                     "\t\tReal MATC \"-(Is/Carea) * (Ncond/Cp) * sin(WE * (tx(0)-tx(1)) - 3*Shift + Gamma)\"\n"
                     "End\n")

            fo.write("Body Force 10\n"
                     "\tName = \"J_E_PLUS\"\n"
                     "\tCurrent Density = Variable time, timestep size\n"
                     "\t\tReal MATC \"(Is/Carea) * (Ncond/Cp) * sin(WE * (tx(0)-tx(1)) - 4*Shift + Gamma)\"\n"
                     "End\n")

            fo.write("Body Force 11\n"
                     "\tName = \"J_E_MINUS\"\n"
                     "\tCurrent Density = Variable time, timestep size\n"
                     "\t\tReal MATC \"-(Is/Carea) * (Ncond/Cp) * sin(WE * (tx(0)-tx(1)) - 4*Shift + Gamma)\"\n"
                     "End\n")

            fo.write("Body Force 12\n"
                     "\tName = \"J_F_PLUS\"\n"
                     "\tCurrent Density = Variable time, timestep size\n"
                     "\t\tReal MATC \"(Is/Carea) * (Ncond/Cp) * sin(WE * (tx(0)-tx(1)) - 5*Shift + Gamma)\"\n"
                     "End\n")

            fo.write("Body Force 13\n"
                     "\tName = \"J_F_MINUS\"\n"
                     "\tCurrent Density = Variable time, timestep size\n"
                     "\t\tReal MATC \"-(Is/Carea) * (Ncond/Cp) * sin(WE * (tx(0)-tx(1)) - 5*Shift + Gamma)\"\n"
                     "End\n")

            fo.write("\n!--- BODIES ---\n")
            for k, v in bodies.items():
                for item in BODIES:
                    bodyname = item[IDX_BODY_NAME]
                    if bodyname == k:
                        eq = item[IDX_BODY_EQ]
                        mat = item[IDX_BODY_MAT]
                        bf = item[IDX_BODY_FORCE]
                        tg = item[IDX_BODY_TQ_GRP]
                        fo.write("Body {0}\n"
                                    "\tName = {1}\n"
                                    "\tEquation = {2}\n"
                                    "\tMaterial = {3}\n".format(v, k, eq, mat))
                        if bf != '0':
                            fo.write("\tBody Force = {0}\n".format(bf))
                        if tg != '0':
                            fo.write("\tTorque Groups = Integer {0}\n".format(tg))
                        if k == "ROTOR_AIRGAPS":
                            fo.write("\tR Inner = Real {0}\n"
                                     "\tR Outer = Real {1}\n".format(self.r_ag1, self.r_ag2))
                        fo.write("End\n\n")
                        break

            fo.write("Equation 1\n"
                     "\tName = \"Model_Domain\"\n"
                     "\tActive Solvers(6) = 1 2 3 4 5 6\n"
                     "End\n")

            fo.write("\n!--- SOLVERS ---\n")
            fo.write("Solver 1\n"
                    "\tExec Solver = Before Timestep\n"
                    "\tEquation = MeshDeform\n"
                    "\tProcedure = \"RigidMeshMapper\" \"RigidMeshMapper\"\n"
                    "End\n")

            fo.write("\nSolver 2\n"
                    "\tEquation = MgDyn2D\n"
                    "\tProcedure = \"MagnetoDynamics2D\" \"MagnetoDynamics2D\"\n"
                    "\tExec Solver = Always\n"
                    "\tVariable = A\n"
                    "\tNonlinear System Convergence Tolerance = 1.0e-6\n"
                    "\tNonlinear System Max Iterations = 50\n"
                    "\tNonlinear System Min Iterations = 1\n"
                    "\tNonlinear System Newton After Iterations = 7\n"
                    "\tNonlinear System Relaxation Factor = 1\n"
                    "\tNonlinear System Convergence Without Constraints = Logical True\n"
                    "\tNonlinear System Newton After Iterations = 7\n"
                    "\tExport Lagrange Multiplier = Logical True\n"
                    "\tLinear System Abort Not Converged = False\n"
                    "\tLinear System Solver = Iterative\n"
                    "\tLinear System Direct Method = GCR\n"
                    "\tLinear System GCR Restart = 500\n"
                    "\tBicgstabl Polynomial Degree = 4\n"
                    "\tLinear System Preconditioning = ILU2\n"
                    "\tLinear System Max Iterations = 1500\n"
                    "\tLinear System Residual Output = Integer 20\n"
                    "\tLinear System Convergence Tolerance = 1e-7\n"
                    "\tMortar BCs Additive = Logical True\n"
                    "End\n")

            fo.write("\nSolver 3\n"
                    "\tExec Solver = Always\n"
                    "\tEquation = CalcFields\n"
                    "\tPotential Variable = \"A\"\n"
                    "\tProcedure = \"MagnetoDynamics\" \"MagnetoDynamicsCalcFields\"\n"
                    "\tCalculate Nodal Forces = Logical True\n"
                    "\tCalculate Magnetic Vector Potential = Logical True\n"
                    "\tCalculate Winding Voltage = Logical True\n"
                    "\tCalculate Current Density = Logical True\n"
                    "\tCalculate Maxwell Stress = Logical True\n"
                    "\tCalculate JxB = Logical True\n"
                    "\tCalculate Magnetic Field Strength = Logical True\n"
                    "End\n")

            fo.write("\nSolver 4\n"
                    "\tExec Solver = After Timestep\n"
                    "\tProcedure = \"ResultOutputSolve\" \"ResultOutputSolver\"\n"
                    "\tOutput File Name = \"step\"\n"
                    "\tVtu Format = True\n"
                    "\tBinary Output = True\n"
                    "\tSingle Precision = True\n"
                    "\tSave Geometry Ids = True\n"
                    "\tShow Variables = True\n"
                    "End\n")

            fo.write("\nSolver 5\n"
                    "\tExec Solver = After Timestep\n"
                    "\tEquation = SaveLine\n"
                    "\tFilename = \"machine/lines.dat\"\n"
                    "\tProcedure = \"SaveData\" \"SaveLine\"\n"
                    "\tVariable 1 = Magnetic Flux Density 1\n"
                    "\tVariable 2 = Magnetic Flux Density 2\n"
                    "\tVariable 3 = Magnetic Flux Density 3\n"
                    "\tVariable 4 = Magnetic Flux Density e 1\n"
                    "\tVariable 5 = Magnetic Flux Density e 2\n"
                    "\tVariable 6 = Magnetic Flux Density e 3\n"
                    "End\n")

            fo.write("\nSolver 6\n"
                    "\tExec Solver = After Timestep\n"
                    "\tFilename = \"machine/scalars.dat\"\n"
                    "\tProcedure = \"SaveData\" \"SaveScalars\"\n"
                    "\tShow Norm Index = 1\n"
                    "End\n")

            fo.write("\n!--- BOUNDARIES ---\n")
            for k, v in boundaries.items():
                if k == "OUTER_STATOR_BOUNDARY":
                    fo.write("Boundary Condition {0}\n"
                            "\tName = {1}\n"
                            "\tA = Real 0\n"
                            "End\n\n".format(v, k))
                elif k == "STATOR_MASTER_BOUNDARY":
                    for k1, v1 in boundaries.items():
                        if k1 == "STATOR_SLAVE_BOUNDARY":
                            slave = v1
                            break
                    if self.is_even:
                        fo.write("Boundary Condition {0}\n"
                                "\tName = {1}\n"
                                "\tMortar BC = Integer {2}\n"
                                "\tMortar BC Static = Logical True\n"
                                "\tRadial Projector = Logical True\n" 
                                "\tGalerkin Projector = Logical True\n"
                                "End\n\n".format(v, k, slave))
                    else:
                        fo.write("Boundary Condition {0}\n"
                                 "\tName = {1}\n"
                                 "\tMortar BC = Integer {2}\n"
                                 "\tMortar BC Static = Logical True\n"
                                 "\tAnti Radial Projector = Logical True\n"
                                 "\tGalerkin Projector = Logical True\n"
                                 "End\n\n".format(v, k, slave))
                elif k == "ROTOR_MASTER_BOUNDARY":
                    for k1, v1 in boundaries.items():
                        if k1 == "ROTOR_SLAVE_BOUNDARY":
                            slave = v1
                            break
                    if self.is_even:
                        fo.write("Boundary Condition {0}\n"
                                "\tName = {1}\n"
                                "\tMortar BC = Integer {2}\n"
                                "\tMortar BC Static = Logical True\n"
                                "\tRadial Projector = Logical True\n" 
                                "\tGalerkin Projector = Logical True\n"
                                "End\n\n".format(v, k, slave))
                    else:
                        fo.write("Boundary Condition {0}\n"
                                 "\tName = {1}\n"
                                 "\tMortar BC = Integer {2}\n"
                                 "\tMortar BC Static = Logical True\n"
                                 "\tAnti Radial Projector = Logical True\n"
                                 "\tGalerkin Projector = Logical True\n"
                                 "End\n\n".format(v, k, slave))
                elif k == "STATOR_SLIDING_BOUNDARY":
                    for k1, v1 in boundaries.items():
                        if k1 == "ROTOR_SLIDING_BOUNDARY":
                            slave = v1
                            break
                    fo.write("Boundary Condition {0}\n"
                            "\tName = {1}\n"
                            "\tMortar BC = Integer {2}\n"
                            "\tRotational Projector = Logical True\n"
                            "\tGalerkin Projector = Logical True\n"
                            "End\n\n".format(v, k, slave))
                elif k == "STATOR_AIRGAP_ARC_BOUNDARY":
                    fo.write("Boundary Condition {0}\n"
                            "\tName = {1}\n"
                            "\tSave Line = True\n"
                            "End\n\n".format(v, k))
                else:
                    fo.write("Boundary Condition {0}\n"
                             "\tName = {1}\n"
                             "End\n\n".format(v, k))
        return True




    def solve(self):
        cmd = ['ElmerSolver', 'emanfes_elmer.sif']
        process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        (stdout, stderr) = process.communicate()
        process.wait()
        if process.returncode != 0:
            print(stdout)
            print(stderr)
            return False
        return True

    def post_processing(self):
        from emanfes.results import Result
        res = Result()

        import numpy as np

        from scipy.interpolate import CubicSpline
        # This order must match scalars.dat.names
        #   1: res: eddy current power
        #   2: res: magnetic field energy
        #   3: res: air gap torque
        #   4: res: inertial volume
        #   5: res: inertial moment
        #   6: res: group 1 torque
        ecp, mfe, agt, iv, im, tq = np.loadtxt('machine/scalars.dat', unpack=True, usecols=(0,1,2,3,4,5))
        x_axis = np.linspace(0, self.time_step*self.steps, self.steps)
        #res.cogging_torque_2_x = x_axis
        #res.cogging_torque_2_y = agt * self.fractions * self.stack_length
        res.cogging_torque_x = x_axis
        res.cogging_torque_y = tq * self.fractions * self.stack_length


        # This order must match lines.dat.names
        #   1: Time step
        #   2: Iteration step
        #   3: Boundary condition
        #   4: Node index
        #   5: coordinate 1
        #   6: coordinate 2
        #   7: coordinate 3
        #   8: magnetic flux density 1
        #   9: magnetic flux density 2
        #   10: magnetic flux density 3
        #   11: magnetic flux density e 1
        #   12: magnetic flux density e 2
        #   13: magnetic flux density e 3

        data = np.loadtxt('machine/lines.dat', usecols=(0,4,5,7,8,10,11))
        Br_list = []
        Bt_list = []
        theta_fine = np.linspace(0, 2*PI, num=720)
        for i in range(1, self.steps+1 ):
            index = np.where(data==i)
            data_step = data[index[0]]
            rho = np.sqrt( data_step[:,1]**2 + data_step[:,2]**2 )
            theta = np.arctan2( data_step[:,2], data_step[:,1] )
            Br1 = np.multiply( data_step[:,3], np.cos(theta) ) + np.multiply( data_step[:,4], np.sin(theta))
            Bt1 = -np.multiply(data_step[:, 3], np.sin(theta)) + np.multiply(data_step[:, 4], np.cos(theta))
            #Br2 = np.multiply(data_step[:, 5], np.cos(theta)) + np.multiply(data_step[:, 6], np.sin(theta))
            #Bt2 = -np.multiply(data_step[:, 5], np.sin(theta)) + np.multiply(data_step[:, 6], np.cos(theta))

            data_step_polar = np.stack( (rho, theta, Br1, Bt1), axis=-1 )

            data_step_polar = data_step_polar[ data_step_polar[:,1].argsort() ]

            cs_r = CubicSpline(data_step_polar[:,1], data_step_polar[:,2], extrapolate='periodic')
            cs_t = CubicSpline(data_step_polar[:,1], data_step_polar[:, 3], extrapolate='periodic')


            Br_list.append( cs_r(theta_fine) )
            Bt_list.append( cs_t(theta_fine) )

        Br = np.array( Br_list )
        Bt = np.array( Bt_list )

        Tq = (self.stack_length * (self.r_middle_ag**2) / MU0 ) * np.trapz( Br * Bt, axis=1, dx=theta_fine[1] )

        res.cogging_torque_mst_x = x_axis
        res.cogging_torque_mst_y = Tq
        res.nl_Bg_r = Br
        res.nl_Bg_t = Bt
        res.nl_Bg_theta = theta_fine


        return res